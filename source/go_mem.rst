Introduction
------------

Goのメモリモデルは、ある変数に対して、あるゴルーチンから変数に書き込みされた値を、別のゴルーチンが参照できることを保証する条件を示します。

Advice
------

複数のゴルーチンによって同時にアクセスされるデータを変更するプログラムは、シリアルにアクセスする必要があります。

アクセスをシリアル化するには、チャネルや ``sync`` パッケージや ``sync/atomic`` パッケージといった同期プリミティブを用いてデータを保護する必要があります。

プログラムの動作を理解するためにこのドキュメントの残りを読む必要がある場合は、あまりにも賢いです。

プログラムの振る舞いを理解するために本ドキュメントを読むことは、十分に役に立ちます。

.. todo:: Don't be clever.(どういう意味?)

Happens Before
--------------

1つのゴルーチン内で、読み取りと書き込みは、プログラムで指定された順序で実行されたかのように動作する必要があります。 つまり、コンパイラとプロセッサは、リオーダーによって言語仕様で定義されているようなゴルーチンの振る舞いを変えることがない場合に限り、単一のゴルーチンで実行された読み書きをリオーダーすることができます。リオーダーのため、あるゴルーチンで観測される実行順序は、別のゴルーチンで認識される順序と異なる場合があります。例えば、あるゴルーチンが ``a = 1; b = 2;`` と実行するとき、別のゴルーチンは ``a`` の値が更新される前に ``b`` の値が更新されていることを観測するかもしれません。

読み取りと書き込みの要件を指定するために、Goのプログラムでのメモリ操作の実行に関する半順序関係を定義します。 イベントe1がイベントe2の前に発生する場合、e2はe1の後に発生すると言います。 また、e1がe2の前に発生せず、e2の後に発生しない場合、e1とe2は同時に発生します。

単一のゴルーチン内では、半順序関係はプログラムによって表される順序です。

``v`` への更新 ``w`` を変数 ``v`` の参照 ``r`` が認識できるのは次の両方が成り立つ場合です。

#. w は r の前に発生する
#. w の後に r の前に ``v`` に対する別の更新 w' がない

変数 ``v`` の参照 r が v への特定の更新 w を認識することを保証するには、r が認識できる更新が w のみであることを確実にする必要があります。つまり、次の両方が成り立つ場合、 r は w を認識できることが保証されます。

#. r の前に w が発生する
#. 共有変数 ``v`` への任意の更新が w の前に発生するか r の後に発生する

この条件のペアは、最初のペアよりも強力です。 w または r と同時に発生する他の更新がないことが必要です。

単一のゴルーチン内では、同時実行性がないため、2つの定義は同等です。参照 r は、v への最新の更新 w によって更新された値を認識します。複数のゴルーチンが共有変数 v にアクセスする場合、必ず同期イベントを使用して、望ましい更新結果を参照が確実に認識するよう半順序関係の条件を成立させる必要があります。

v の型のゼロ値を用いて変数 v を初期化する場合は、メモリモデルの中では更新として動作します。

そのマシンの一語より大きい値の参照および更新は、順不同の複数のマシンワードサイズの処理として振舞います。

同期(Synchronization)
------------------------------

初期化(Initialization)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

プログラムの初期化は単一のゴルーチンで実行されますが、そのゴルーチンは同時に実行される別のゴルーチンを作成することがあります。

パッケージ p がパッケージ q をインポートする場合、 q の init 関数は、任意の p の開始よりも前に完了します。

関数 ``main.main`` の開始は、すべての ``init`` 関数が完了した後に発生します。

ゴルーチンの生成(Goroutine creation)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

新しいゴルーチンを開始する ``go`` ステートメントは、ゴルーチンの実行が始まる前に発生します。

例として次のプログラムを見てみます。

.. code-block:: go

    var a string
    
    func f() {
        print(a)
    }
    
    func hello() {
        a = "hello, world"
        go f()
    }


``hello`` を呼び出すと、未来のある時点(おそらく ``hello`` が戻った後)で「hello、world」が出力されます。

ゴルーチンの破壊(Goroutine destruction)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ゴルーチンの終了は、プログラム内のイベントの前に発生することが保証されていません。例として以下のプログラムを見てみます。

::

       var a string
       
       func hello() {
           go func() { a = "hello" }()
           print(a)
       }
       

a への割り当ての後に同期イベントが続くことはないため、他のゴルーチンによって認識されることは保証されません。実際、意欲的なコンパイラーは ``go`` ステートメント全体を削除する場合があります。

ゴルーチンの影響を別のゴルーチンで観察する必要がある場合は、ロックやチャネル通信などの同期メカニズムを使用して、相対的な順序を確立します。

チャネル通信(Channel communication)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

チャネル通信は、ゴルーチンを同期させる主な方法です。特定のチャネルでのそれぞれの送信は、そのチャネルからの対応する受信と関連しており、通常は別のゴルーチンで行われます。

あるチャネルでの送信は、そのチャネルからの対応する受信が完了する前に行われます。

以下の例です。

::

       var c = make(chan int, 10)
       var a string
       
       func f() {
           a = "hello, world"
           c <- 0
       }
       
       func main() {
           go f()
           <-c
           print(a)
       }
       

これは "hello, world" と表示されることが保証されています。a への書き込みは、c への送信の前に行われ、対応する c への受信が完了する前に行われ、Print の前に行われます。

チャネルのクローズは、チャネルがクローズされているため、ゼロ値を返す受信の前に起こります。

前の例では、c <- 0 を close(c) に置き換えると、同じ動作が保証されたプログラムが得られます。

バッファリングされていないチャネルからの受信は、そのチャネルの送信が完了する前に行われます。

このプログラム（上の例と同じですが、送信の文と受信の文を入れ替え、バッファリングされていないチャネルを使用しています）。

::

       var c = make(chan int)
       var a string
       
       func f() {
           a = "hello, world"
           <-c
       }
       
       func main() {
           go f()
           c <- 0
           print(a)
       }
       

これは、"hello, world" を Print することも保証されています。 a への書き込みは c の受信よりも前に、かつ、対応する c の送信が完了する前にかつ、Print の前に行われます。

チャネルがバッファリングされていた場合 (例えば、c = make(chan int, 1))、プログラムは "hello, world" を表示することを保証しません (空の文字列を表示したり、クラッシュしたりするかもしれません)。(空の文字列を表示したり、クラッシュしたり、何か他のことをするかもしれません)。

容量 C のチャネルでの k 回目の受信は、そのチャネルからの k+C 回目の送信が完了する前に起こります。

この規則は前の規則をバッファリングされたチャネルに一般化したものです。チャネル内のアイテムの数はアクティブに使っている数に対応し、チャネルの容量は同時に使用する最大数に対応し、アイテムを送信することでセマフォを獲得し、アイテムを受信することでセマフォを解放します。これは、同時実行性を制限するための一般的な慣用句です。

このプログラムでは、ワークリストの各エントリに対してゴルーチンを開始しますが、ゴルーチンは制限されたチャネルを使用して調整し、最大でも3つのワーク関数が同時に実行されるようにしています。

::

       var limit = make(chan int, 3)
       
       func main() {
           for _, w := range work {
               go func(w func()) {
                   limit <- 1
                   w()
                   <-limit
               }(w)
           }
           select{}
       }
       

ロック(Locks)
~~~~~~~~~~~~~~~~

sync パッケージは、sync.Mutex と sync.RWMutex という二つのロックデータ型を実装しています。

任意の sync.Mutex または sync.RWMutex 変数 l と n < m の場合、l.Lock() の呼び出し m が返される前に l.Unlock() の呼び出し n が行われます。

::

       var l sync.Mutex
       var a string
       
       func f() {
           a = "hello, world"
           l.Unlock()
       }
       
       func main() {
           l.Lock()
           go f()
           l.Lock()
           print(a)
       }

このプログラムは、"hello, world "を出力することが保証されています。l.Unlock() (f) の最初の呼び出しは、l.Lock() (main) の 2 番目の呼び出しが返ってくる前に行われ、これは出力の前に行われます。

sync.RWMutex 変数 l 上の l.RLock への任意の呼び出しについては、l.Unlock への呼び出し n の後に l.RLock が発生(戻り)し、一致する l.RUnlock が l.Lock への呼び出し n+1 の前に発生するような n が存在します。

Once
~~~~

sync パッケージは、 Once 型を使用することで、複数のゴルーチンが存在する場合に初期化のための安全なメカニズムを提供します。複数のスレッドが特定の f に対して once.Do(f) を実行することができますが、f() を実行するのは 1 つだけで、他の呼び出しは f() が戻るまでブロックされます。

once.Do(f) からの単一の f() の呼び出しは、 once.Do(f) の呼び出しが返ってくる前に発生します(返ってきます)。

::

       var a string
       var once sync.Once
       
       func setup() {
           a = "hello, world"
       }
       
       func doprint() {
           once.Do(setup)
           print(a)
       }
       
       func twoprint() {
           go doprint()
           go doprint()
       }

このプログラムでは、twoprint を呼び出すと setup が 1 回だけ呼び出されます。セットアップ関数は、どちらかのprintを呼び出す前に完了します。その結果、"hello, world" が2回出力されることになります。

誤った同期(Incorrect synchronization)
--------------------------------------------------

読み取り r は、r と同時に発生した書き込み w によって書き込まれた値を観測する可能性があることに注意してください。このような場合でも、r の後に発生した読み取りが w の前に発生した書き込みを観測することを意味するわけではありません。

::

       var a, b int
       
       func f() {
           a = 1
           b = 2
       }
       
       func g() {
           print(b)
           print(a)
       }
       
       func main() {
           go f()
           g()
       }

このプログラムでは、g が 2 を表示してから 0 を表示することがあります。

この事実は、いくつかの一般的なイディオムを無効にします。

ダブルチェックロックは同期化のオーバーヘッドを避けるための試みです。例えば、twooprintプログラムは次のように誤って書かれているかもしれません。

::

       var a string
       var done bool
       
       func setup() {
           a = "hello, world"
           done = true
       }
       
       func doprint() {
           if !done {
               once.Do(setup)
           }
           print(a)
       }
       
       func twoprint() {
           go doprint()
           go doprint()
       }

このバージョンでは、"hello, world "の代わりに空の文字列を表示することができます。

もう一つの間違ったイディオムは、次のように、値を待つのにビジーループを用いることです。

::

       var a string
       var done bool
       
       func setup() {
           a = "hello, world"
           done = true
       }
       
       func main() {
           go setup()
           for !done {
           }
           print(a)
       }

前述のように、main で done への書き込みを観測することが a への書き込みを観測することを意味するという保証はないので、このプログラムも空の文字列を表示する可能性があります。さらに悪いことに、2 つのスレッド間には同期イベントがないので、 done への書き込みが main で観測されるという保証はありません。main のループが終了することは保証されていません。

このテーマには、このプログラムのような微妙な亜種があります。

::

       type T struct {
           msg string
       }
       
       var g *T
       
       func setup() {
           t := new(T)
           t.msg = "hello, world"
           g = t
       }
       
       func main() {
           go setup()
           for g == nil {
           }
           print(g.msg)
       }

main が g != nil を観測してループを終了したとしても、g.msg の初期化値を観測できる保証はありません。

これらの例では、解決策はすべて同じです。
