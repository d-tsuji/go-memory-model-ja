
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>Introduction &#8212; The Go Memory Model  ドキュメント</title>
    <link rel="stylesheet" href="_static/traditional.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/translations.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="next" title="TODO(内部用)" href="todo.html" />
    <link rel="prev" title="The Go Memory Model" href="index.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="todo.html" title="TODO(内部用)"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="index.html" title="The Go Memory Model"
             accesskey="P">前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">The Go Memory Model  ドキュメント</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>Goのメモリモデルは、ある変数に対して、あるゴルーチンから変数に書き込みされた値を、別のゴルーチンが参照できることを保証する条件を示します。</p>
</div>
<div class="section" id="advice">
<h1>Advice<a class="headerlink" href="#advice" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>複数のゴルーチンによって同時にアクセスされるデータを変更するプログラムは、シリアルにアクセスする必要があります。</p>
<p>アクセスをシリアル化するには、チャネルや <code class="docutils literal notranslate"><span class="pre">sync</span></code> パッケージや <code class="docutils literal notranslate"><span class="pre">sync/atomic</span></code> パッケージといった同期プリミティブを用いてデータを保護する必要があります。</p>
<p>プログラムの動作を理解するためにこのドキュメントの残りを読む必要がある場合は、あまりにも賢いです。</p>
<p>プログラムの振る舞いを理解するために本ドキュメントを読むことは、十分に役に立ちます。</p>
<div class="admonition-todo admonition" id="id1">
<p class="admonition-title">課題</p>
<p>Don't be clever.(どういう意味?)</p>
</div>
</div>
<div class="section" id="happens-before">
<h1>Happens Before<a class="headerlink" href="#happens-before" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>1つのゴルーチン内で、読み取りと書き込みは、プログラムで指定された順序で実行されたかのように動作する必要があります。 つまり、コンパイラとプロセッサは、リオーダーによって言語仕様で定義されているようなゴルーチンの振る舞いを変えることがない場合に限り、単一のゴルーチンで実行された読み書きをリオーダーすることができます。リオーダーのため、あるゴルーチンで観測される実行順序は、別のゴルーチンで認識される順序と異なる場合があります。例えば、あるゴルーチンが <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">1;</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">2;</span></code> と実行するとき、別のゴルーチンは <code class="docutils literal notranslate"><span class="pre">a</span></code> の値が更新される前に <code class="docutils literal notranslate"><span class="pre">b</span></code> の値が更新されていることを観測するかもしれません。</p>
<p>読み取りと書き込みの要件を指定するために、Goのプログラムでのメモリ操作の実行に関する半順序関係を定義します。 イベントe1がイベントe2の前に発生する場合、e2はe1の後に発生すると言います。 また、e1がe2の前に発生せず、e2の後に発生しない場合、e1とe2は同時に発生します。</p>
<p>単一のゴルーチン内では、半順序関係はプログラムによって表される順序です。</p>
<p><code class="docutils literal notranslate"><span class="pre">v</span></code> への更新 <code class="docutils literal notranslate"><span class="pre">w</span></code> を変数 <code class="docutils literal notranslate"><span class="pre">v</span></code> の参照 <code class="docutils literal notranslate"><span class="pre">r</span></code> が認識できるのは次の両方が成り立つ場合です。</p>
<ol class="arabic simple">
<li><p>w は r の前に発生する</p></li>
<li><p>w の後に r の前に <code class="docutils literal notranslate"><span class="pre">v</span></code> に対する別の更新 w' がない</p></li>
</ol>
<p>変数 <code class="docutils literal notranslate"><span class="pre">v</span></code> の参照 r が v への特定の更新 w を認識することを保証するには、r が認識できる更新が w のみであることを確実にする必要があります。つまり、次の両方が成り立つ場合、 r は w を認識できることが保証されます。</p>
<ol class="arabic simple">
<li><p>r の前に w が発生する</p></li>
<li><p>共有変数 <code class="docutils literal notranslate"><span class="pre">v</span></code> への任意の更新が w の前に発生するか r の後に発生する</p></li>
</ol>
<p>この条件のペアは、最初のペアよりも強力です。 w または r と同時に発生する他の更新がないことが必要です。</p>
<p>単一のゴルーチン内では、同時実行性がないため、2つの定義は同等です。参照 r は、v への最新の更新 w によって更新された値を認識します。複数のゴルーチンが共有変数 v にアクセスする場合、必ず同期イベントを使用して、望ましい更新結果を参照が確実に認識するよう半順序関係の条件を成立させる必要があります。</p>
<p>v の型のゼロ値を用いて変数 v を初期化する場合は、メモリモデルの中では更新として動作します。</p>
<p>そのマシンの一語より大きい値の参照および更新は、順不同の複数のマシンワードサイズの処理として振舞います。</p>
</div>
<div class="section" id="synchronization">
<h1>同期(Synchronization)<a class="headerlink" href="#synchronization" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="section" id="initialization">
<h2>初期化(Initialization)<a class="headerlink" href="#initialization" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>プログラムの初期化は単一のゴルーチンで実行されますが、そのゴルーチンは同時に実行される別のゴルーチンを作成することがあります。</p>
<p>パッケージ p がパッケージ q をインポートする場合、 q の init 関数は、任意の p の開始よりも前に完了します。</p>
<p>関数 <code class="docutils literal notranslate"><span class="pre">main.main</span></code> の開始は、すべての <code class="docutils literal notranslate"><span class="pre">init</span></code> 関数が完了した後に発生します。</p>
</div>
<div class="section" id="goroutine-creation">
<h2>ゴルーチンの生成(Goroutine creation)<a class="headerlink" href="#goroutine-creation" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>新しいゴルーチンを開始する <code class="docutils literal notranslate"><span class="pre">go</span></code> ステートメントは、ゴルーチンの実行が始まる前に発生します。</p>
<p>例として次のプログラムを見てみます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">a</span> <span class="kt">string</span>

<span class="kd">func</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">print</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">hello</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">a</span> <span class="p">=</span> <span class="s">&quot;hello, world&quot;</span>
    <span class="k">go</span> <span class="nx">f</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">hello</span></code> を呼び出すと、未来のある時点(おそらく <code class="docutils literal notranslate"><span class="pre">hello</span></code> が戻った後)で「hello、world」が出力されます。</p>
</div>
<div class="section" id="goroutine-destruction">
<h2>ゴルーチンの破壊(Goroutine destruction)<a class="headerlink" href="#goroutine-destruction" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ゴルーチンの終了は、プログラム内のイベントの前に発生することが保証されていません。例として以下のプログラムを見てみます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">a</span> <span class="n">string</span>

<span class="n">func</span> <span class="n">hello</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">go</span> <span class="n">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span> <span class="p">}()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>a への割り当ての後に同期イベントが続くことはないため、他のゴルーチンによって認識されることは保証されません。実際、意欲的なコンパイラーは <code class="docutils literal notranslate"><span class="pre">go</span></code> ステートメント全体を削除する場合があります。</p>
<p>ゴルーチンの影響を別のゴルーチンで観察する必要がある場合は、ロックやチャネル通信などの同期メカニズムを使用して、相対的な順序を確立します。</p>
</div>
<div class="section" id="channel-communication">
<h2>チャネル通信(Channel communication)<a class="headerlink" href="#channel-communication" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>チャネル通信は、ゴルーチンを同期させる主な方法です。特定のチャネルでのそれぞれの送信は、そのチャネルからの対応する受信と関連しており、通常は別のゴルーチンで行われます。</p>
<p>あるチャネルでの送信は、そのチャネルからの対応する受信が完了する前に行われます。</p>
<p>以下の例です。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">c</span> <span class="o">=</span> <span class="n">make</span><span class="p">(</span><span class="n">chan</span> <span class="nb">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">var</span> <span class="n">a</span> <span class="n">string</span>

<span class="n">func</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;hello, world&quot;</span>
    <span class="n">c</span> <span class="o">&lt;-</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">go</span> <span class="n">f</span><span class="p">()</span>
    <span class="o">&lt;-</span><span class="n">c</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これは &quot;hello, world&quot; と表示されることが保証されています。a への書き込みは、c への送信の前に行われ、対応する c への受信が完了する前に行われ、Print の前に行われます。</p>
<p>チャネルのクローズは、チャネルがクローズされているため、ゼロ値を返す受信の前に起こります。</p>
<p>前の例では、c &lt;- 0 を close(c) に置き換えると、同じ動作が保証されたプログラムが得られます。</p>
<p>バッファリングされていないチャネルからの受信は、そのチャネルの送信が完了する前に行われます。</p>
<p>このプログラム（上の例と同じですが、送信の文と受信の文を入れ替え、バッファリングされていないチャネルを使用しています）。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">c</span> <span class="o">=</span> <span class="n">make</span><span class="p">(</span><span class="n">chan</span> <span class="nb">int</span><span class="p">)</span>
<span class="n">var</span> <span class="n">a</span> <span class="n">string</span>

<span class="n">func</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;hello, world&quot;</span>
    <span class="o">&lt;-</span><span class="n">c</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">go</span> <span class="n">f</span><span class="p">()</span>
    <span class="n">c</span> <span class="o">&lt;-</span> <span class="mi">0</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これは、&quot;hello, world&quot; を Print することも保証されています。 a への書き込みは c の受信よりも前に、かつ、対応する c の送信が完了する前にかつ、Print の前に行われます。</p>
<p>チャネルがバッファリングされていた場合 (例えば、c = make(chan int, 1))、プログラムは &quot;hello, world&quot; を表示することを保証しません (空の文字列を表示したり、クラッシュしたりするかもしれません)。(空の文字列を表示したり、クラッシュしたり、何か他のことをするかもしれません)。</p>
<p>容量 C のチャネルでの k 回目の受信は、そのチャネルからの k+C 回目の送信が完了する前に起こります。</p>
<p>この規則は前の規則をバッファリングされたチャネルに一般化したものです。チャネル内のアイテムの数はアクティブに使っている数に対応し、チャネルの容量は同時に使用する最大数に対応し、アイテムを送信することでセマフォを獲得し、アイテムを受信することでセマフォを解放します。これは、同時実行性を制限するための一般的な慣用句です。</p>
<p>このプログラムでは、ワークリストの各エントリに対してゴルーチンを開始しますが、ゴルーチンは制限されたチャネルを使用して調整し、最大でも3つのワーク関数が同時に実行されるようにしています。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">make</span><span class="p">(</span><span class="n">chan</span> <span class="nb">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="n">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">w</span> <span class="o">:=</span> <span class="nb">range</span> <span class="n">work</span> <span class="p">{</span>
        <span class="n">go</span> <span class="n">func</span><span class="p">(</span><span class="n">w</span> <span class="n">func</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">limit</span> <span class="o">&lt;-</span> <span class="mi">1</span>
            <span class="n">w</span><span class="p">()</span>
            <span class="o">&lt;-</span><span class="n">limit</span>
        <span class="p">}(</span><span class="n">w</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">select</span><span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="locks">
<h2>ロック(Locks)<a class="headerlink" href="#locks" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>sync パッケージは、sync.Mutex と sync.RWMutex という二つのロックデータ型を実装しています。</p>
<p>任意の sync.Mutex または sync.RWMutex 変数 l と n &lt; m の場合、l.Lock() の呼び出し m が返される前に l.Unlock() の呼び出し n が行われます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">l</span> <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>
<span class="n">var</span> <span class="n">a</span> <span class="n">string</span>

<span class="n">func</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;hello, world&quot;</span>
    <span class="n">l</span><span class="o">.</span><span class="n">Unlock</span><span class="p">()</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">l</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
    <span class="n">go</span> <span class="n">f</span><span class="p">()</span>
    <span class="n">l</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このプログラムは、&quot;hello, world &quot;を出力することが保証されています。l.Unlock() (f) の最初の呼び出しは、l.Lock() (main) の 2 番目の呼び出しが返ってくる前に行われ、これは出力の前に行われます。</p>
<p>sync.RWMutex 変数 l 上の l.RLock への任意の呼び出しについては、l.Unlock への呼び出し n の後に l.RLock が発生(戻り)し、一致する l.RUnlock が l.Lock への呼び出し n+1 の前に発生するような n が存在します。</p>
</div>
<div class="section" id="once">
<h2>Once<a class="headerlink" href="#once" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>sync パッケージは、 Once 型を使用することで、複数のゴルーチンが存在する場合に初期化のための安全なメカニズムを提供します。複数のスレッドが特定の f に対して once.Do(f) を実行することができますが、f() を実行するのは 1 つだけで、他の呼び出しは f() が戻るまでブロックされます。</p>
<p>once.Do(f) からの単一の f() の呼び出しは、 once.Do(f) の呼び出しが返ってくる前に発生します(返ってきます)。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">a</span> <span class="n">string</span>
<span class="n">var</span> <span class="n">once</span> <span class="n">sync</span><span class="o">.</span><span class="n">Once</span>

<span class="n">func</span> <span class="n">setup</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;hello, world&quot;</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">doprint</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">once</span><span class="o">.</span><span class="n">Do</span><span class="p">(</span><span class="n">setup</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">twoprint</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">go</span> <span class="n">doprint</span><span class="p">()</span>
    <span class="n">go</span> <span class="n">doprint</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このプログラムでは、twoprint を呼び出すと setup が 1 回だけ呼び出されます。セットアップ関数は、どちらかのprintを呼び出す前に完了します。その結果、&quot;hello, world&quot; が2回出力されることになります。</p>
</div>
</div>
<div class="section" id="incorrect-synchronization">
<h1>誤った同期(Incorrect synchronization)<a class="headerlink" href="#incorrect-synchronization" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>読み取り r は、r と同時に発生した書き込み w によって書き込まれた値を観測する可能性があることに注意してください。このような場合でも、r の後に発生した読み取りが w の前に発生した書き込みを観測することを意味するわけではありません。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="nb">int</span>

<span class="n">func</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">g</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">go</span> <span class="n">f</span><span class="p">()</span>
    <span class="n">g</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このプログラムでは、g が 2 を表示してから 0 を表示することがあります。</p>
<p>この事実は、いくつかの一般的なイディオムを無効にします。</p>
<p>ダブルチェックロックは同期化のオーバーヘッドを避けるための試みです。例えば、twooprintプログラムは次のように誤って書かれているかもしれません。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>var a string
var done bool

func setup() {
    a = &quot;hello, world&quot;
    done = true
}

func doprint() {
    if !done {
        once.Do(setup)
    }
    print(a)
}

func twoprint() {
    go doprint()
    go doprint()
}
</pre></div>
</div>
<p>このバージョンでは、&quot;hello, world &quot;の代わりに空の文字列を表示することができます。</p>
<p>もう一つの間違ったイディオムは、次のように、値を待つのにビジーループを用いることです。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>var a string
var done bool

func setup() {
    a = &quot;hello, world&quot;
    done = true
}

func main() {
    go setup()
    for !done {
    }
    print(a)
}
</pre></div>
</div>
<p>前述のように、main で done への書き込みを観測することが a への書き込みを観測することを意味するという保証はないので、このプログラムも空の文字列を表示する可能性があります。さらに悪いことに、2 つのスレッド間には同期イベントがないので、 done への書き込みが main で観測されるという保証はありません。main のループが終了することは保証されていません。</p>
<p>このテーマには、このプログラムのような微妙な亜種があります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">T</span> <span class="n">struct</span> <span class="p">{</span>
    <span class="n">msg</span> <span class="n">string</span>
<span class="p">}</span>

<span class="n">var</span> <span class="n">g</span> <span class="o">*</span><span class="n">T</span>

<span class="n">func</span> <span class="n">setup</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">t</span> <span class="o">:=</span> <span class="n">new</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;hello, world&quot;</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">t</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">go</span> <span class="n">setup</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">g</span> <span class="o">==</span> <span class="n">nil</span> <span class="p">{</span>
    <span class="p">}</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">msg</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>main が g != nil を観測してループを終了したとしても、g.msg の初期化値を観測できる保証はありません。</p>
<p>これらの例では、解決策はすべて同じです。</p>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">Introduction</a></li>
<li><a class="reference internal" href="#advice">Advice</a></li>
<li><a class="reference internal" href="#happens-before">Happens Before</a></li>
<li><a class="reference internal" href="#synchronization">同期(Synchronization)</a><ul>
<li><a class="reference internal" href="#initialization">初期化(Initialization)</a></li>
<li><a class="reference internal" href="#goroutine-creation">ゴルーチンの生成(Goroutine creation)</a></li>
<li><a class="reference internal" href="#goroutine-destruction">ゴルーチンの破壊(Goroutine destruction)</a></li>
<li><a class="reference internal" href="#channel-communication">チャネル通信(Channel communication)</a></li>
<li><a class="reference internal" href="#locks">ロック(Locks)</a></li>
<li><a class="reference internal" href="#once">Once</a></li>
</ul>
</li>
<li><a class="reference internal" href="#incorrect-synchronization">誤った同期(Incorrect synchronization)</a></li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="index.html"
                        title="前の章へ">The Go Memory Model</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="todo.html"
                        title="次の章へ">TODO(内部用)</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/go_mem.rst.txt"
            rel="nofollow">ソースコードを表示</a></li>
    </ul>
   </div><div>
    <h4>Page Info</h4>
    <p>
        <ul>
            <li>英数記号: 976</li>
            <li>非アスキー: 3505</li>
            <li>合計文字数: 4481</li>
            <li>半角換算: 7986</li>
            <li>全角換算: 3993.0</li>
        </ul>
    </p>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">クイック検索</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="検索" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="todo.html" title="TODO(内部用)"
             >次へ</a> |</li>
        <li class="right" >
          <a href="index.html" title="The Go Memory Model"
             >前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">The Go Memory Model  ドキュメント</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, d-tsuji.
      このドキュメントは <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.4 で生成しました。
    </div>
  </body>
</html>